[[insns-vsm3me, SM3 Message Expansion]]
= vsm3me.vv

Synopsis::
Vector SM3 Message Expansion - 8 rounds per instruction

Mnemonic::
vsm3me.vv vd, vs2, vs1

Encoding::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 'OP-V'},
{bits: 5, name: 'vd'},
{bits: 3, name: 'OPIVV'},
{bits: 5, name: 'vs1'},
{bits: 5, name: 'vs2'},
{bits: 1, name: '1'},
{bits: 6, name: 'funct6'},
]}
....

Arguments::

[%autowidth]
[%header,cols="4,2,2,2,2,2"]
|===
|Register
|Direction
|EGW
|EGS 
|EEW
|Definition

| Vs1 | input  | 256  | 8 | 32 | Message words W[0:7]
| Vs2 | input  | 256  | 8 | 32 | Message words W[8:15]
| Vd  | output | 256  | 8 | 32 | Message words W[16:23]
|===

Description:: 
This instruction implements 8 rounds of SM3 message expansion,  producing eight 32-bit
outputs in a 256-bit 8-element group.
It treats each 256-bit 8-element group of `vs1` and `vs2` as the data input.


This instruction treats `EEW=32` and `EGS=8`, regardless of `vtype.vsew`
`vl` needs to be set to eight times the number of element groups.
If vstart is not zero, it needs to be scaled similarly.
// This instruction requires that `Zvl256b` be implemented (i.e `VLEN>=256`).

Note::
For the best performance, it is recommended that implementations have VLEN>=256.
When VLEN<EGW, an appropriate LMUL needs to be used by software so that elements from the 
specified register groups can be combined to form the full element group.

It is important to note that ELEN>=SEW is a requirement as elements are not
permitted to cross register boundaries.


Operation::
[source,pseudocode]
--
function clause execute (VSM3ME(vs2, vs1)) = {
  assert((vl%EGS)<>0)       // vl must be a multiple of EGS
  assert((vstart%EGS)<>0) //  vstart must be a multiple of EGS
  // assert round key in range

  elementgroups = (vl/EGS)
  egstart = (vstart/EGS)
  
  foreach (i from egstart to elementgroups) {
    // let current : bits(128) = get_velem(vs2, EGW=128, i);
    // let rk[3:0] = current // This pseudo code is temporary - it will be rewritten!!!!!!!!!!!!
  
W[i]   = P_1(W[i-16]^W[i-9]^ROTL15W[i-3]) ^ROTL7W[i-13]^W[i-6]
W[i+1] = P_1(W[i-15]^W[i-8]^ROTL15W[i-2]) ^ROTL7W[i-12]^W[i-5]
W[i+2] = P_1(W[i-14]^W[i-7]^ROTL15W[i-1]) ^ROTL7W[i-11]^W[i-4]
W[i+3] = P_1(W[i-13]^W[i-6]^ROTL15W[i])   ^ROTL7W[i-10]^W[i-3]
W[i+4] = P_1(W[i-12]^W[i-5]^ROTL15W[i+1]) ^ROTL7W[i-9] ^W[i-2]
W[i+5] = P_1(W[i-11]^W[i-4]^ROTL15W[i+2]) ^ROTL7W[i-8] ^W[i-1]
W[i+6] = P_1(W[i-10]^W[i-3]^ROTL15W[i+3]) ^ROTL7W[i-7] ^W[i]
W[i+7] = P_1(W[i-9] ^W[i-2]^ROTL15W[i+4]) ^ROTL7W[i-6] ^W[i+1]

or

W[16] = P_1(W[0]⊕W[7] ⊕ROTL15W[13])⊕ROTL7W[3] ⊕W[10]
W[17] = P_1(W[1]⊕W[8] ⊕ROTL15W[14])⊕ROTL7W[4] ⊕W[11]
W[18] = P_1(W[2]⊕W[9] ⊕ROTL15W[15])⊕ROTL7W[5] ⊕W[12]
W[19] = P_1(W[3]⊕W[10]⊕ROTL15W[16])⊕ROTL7W[6] ⊕W[13]
W[20] = P_1(W[4]⊕W[11]⊕ROTL15W[17])⊕ROTL7W[7] ⊕W[14]
W[21] = P_1(W[5]⊕W[12]⊕ROTL15W[18])⊕ROTL7W[8] ⊕W[15]
W[22] = P_1(W[6]⊕W[13]⊕ROTL15W[19])⊕ROTL7W[9] ⊕W[16]
W[23] = P_1(W[7]⊕W[14]⊕ROTL15W[20])⊕ROTL7W[10]⊕W[17]

or

for i = 16 to 67
  W[i] = P_1(W[i-16] ^ W[i-9]) ^ (ROTL15W[i-3]))
^ (ROTL7W[i-13]) ^ W[i-6]
end for

where:
P_1(X) = X ^ ROTL15(X) ^ ROTL23(X)



  }
  RETIRE_SUCCESS
}
--

Included in::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

| <<zvksh>>
| v0.1.0
| In Development
|===